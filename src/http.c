#include "http.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <time.h>

/**
 * Get appropriate MIME type based on file extension
 * 
 * This function determines the Content-Type header value based on the file extension.
 * Supports common web file types including HTML, CSS, JavaScript, images and more.
 *
 * @param path The file path to analyze
 * @return A string containing the MIME type (defaults to application/octet-stream)
 */
const char *http_get_mime_type(const char *path) {
    const char *ext = strrchr(path, '.');
    if (!ext) return "application/octet-stream";
    
    ext++; /* Skip the dot */
    
    if (strcasecmp(ext, "html") == 0 || strcasecmp(ext, "htm") == 0)
        return "text/html";
    if (strcasecmp(ext, "css") == 0)
        return "text/css";
    if (strcasecmp(ext, "js") == 0)
        return "application/javascript";
    if (strcasecmp(ext, "png") == 0)
        return "image/png";
    if (strcasecmp(ext, "jpg") == 0 || strcasecmp(ext, "jpeg") == 0)
        return "image/jpeg";
    if (strcasecmp(ext, "gif") == 0)
        return "image/gif";
    if (strcasecmp(ext, "svg") == 0)
        return "image/svg+xml";
    if (strcasecmp(ext, "ico") == 0)
        return "image/x-icon";
    if (strcasecmp(ext, "json") == 0)
        return "application/json";
    if (strcasecmp(ext, "xml") == 0)
        return "application/xml";
    if (strcasecmp(ext, "txt") == 0)
        return "text/plain";
    
    return "application/octet-stream";
}

/**
 * Generate an ETag based on file metadata
 * 
 * Creates a weak ETag (prefixed with W/) based on the file's last modification time
 * and size. This allows browsers to cache content and validate freshness without
 * downloading the entire file again.
 *
 * @param mtime The file's last modification time
 * @param size The file size in bytes
 * @return A newly allocated string containing the ETag (caller must free)
 */
char *http_generate_etag(time_t mtime, size_t size) {
    char *etag = malloc(64);
    if (!etag) return NULL;
    
    /* Generate weak ETag based on modification time and size */
    snprintf(etag, 64, "W/\"%lx-%lx\"", (unsigned long)mtime, (unsigned long)size);
    return etag;
}

/**
 * Check if the client's provided ETag matches the server's ETag
 * 
 * This function checks if the If-None-Match header in the client's request
 * matches the ETag generated by the server. Used to implement HTTP 304
 * Not Modified responses for efficient caching.
 *
 * @param request The full HTTP request from the client
 * @param etag The server-generated ETag value
 * @return true if the ETags match, false otherwise
 */
bool http_check_etag_match(const char *request, const char *etag) {
    if (!request || !etag) return false;
    
    const char *if_none_match = strstr(request, "If-None-Match:");
    if (!if_none_match) return false;
    
    return strstr(if_none_match, etag) != NULL;
}

bool http_parse_request(const char *buffer, __attribute__((unused)) size_t length, http_request_t *req) {
    char method[16];
    
    /* Parse request line */
    if (sscanf(buffer, "%15s %255s %15s", method, req->path, req->version) != 3) {
        return false;
    }

    /* Parse method */
    if (strcmp(method, "GET") == 0) {
        req->method = HTTP_GET;
    } else if (strcmp(method, "HEAD") == 0) {
        req->method = HTTP_HEAD;
    } else if (strcmp(method, "POST") == 0) {
        req->method = HTTP_POST;
    } else {
        req->method = HTTP_UNSUPPORTED;
        return false;
    }

    return true;
}

void http_send_response(int client_fd, int status_code, 
                       const char *content_type, 
                       const void *body, size_t body_length,
                       const char *extra_headers) {
    char headers[4096];
    int header_len;

    /* Format headers */
    header_len = snprintf(headers, sizeof(headers),
        "HTTP/1.1 %d %s\r\n"
        "Content-Type: %s\r\n"
        "Content-Length: %zu\r\n"
        "Connection: close\r\n",
        status_code,
        status_code == 200 ? "OK" : "Error",
        content_type,
        body_length);

    /* Add extra headers if provided */
    if (extra_headers) {
        strncat(headers, extra_headers, sizeof(headers) - header_len - 1);
        header_len = strlen(headers);
    }

    /* Add final CRLF */
    strncat(headers, "\r\n", sizeof(headers) - header_len - 1);
    header_len = strlen(headers);

    /* Send headers */
    write(client_fd, headers, header_len);

    /* Send body */
    if (body && body_length > 0) {
        write(client_fd, body, body_length);
    }
}

void http_send_error(int client_fd, int status_code, const char *message) {
    /* Add security headers for error responses too */
    const char *security_headers = 
        "X-Frame-Options: DENY\r\n"
        "X-Content-Type-Options: nosniff\r\n"
        "X-XSS-Protection: 1; mode=block\r\n"
        "Content-Security-Policy: default-src 'self'\r\n"
        "Strict-Transport-Security: max-age=31536000; includeSubDomains\r\n";

    http_send_response(client_fd, status_code, "text/plain", 
                      message, strlen(message), security_headers);
}
